#lang racket

(require racket/format)

; create a pesudo-random number generator
; from now on, pseudo-random integers in [0 .. k-1] can be generated by
; (random k prg)
(define prg (make-pseudo-random-generator))

; non-zero test
(define (non-zero? n) (not (zero? n)))

; declare a structure for the game, with 2 fields:
;   board: will store the 4x4 table of cells with values with content either
;          0 (for unoccupied cell), or a power of 2
;   score: the current score of the played game
(struct Game (board score) #:transparent)

; viewer of the current state of the game
(define (show game)
  (displayln (format "Score: ~a" (Game-score game)))
  (map (lambda (row) 
         (map (lambda (cell)
                (display "|")
                (display (if (= cell 0) ".   " (~v cell #:width 4)))) 
              row)
         (displayln "|")) 
       (Game-board game)))

; (zero-replace n v list) replaces the n-th zero in the list l with v
(define (zero-replace n v l)
  (cond [(or (eq? n 0) (null? l)) l]
        [(and (eq? n 1) (eq? (car l) 0)) (cons v (cdr l))]
        [(eq? (car l) 0) (cons 0 (zero-replace (- n 1) v (cdr l)))]
        [#t (cons (car l) (zero-replace n v (cdr l)))]
))


; (split-4 l) splits a list elements into chunks of lists of 4 elements
(define (split-4 l)
  (if (null? l) l (cons (take l 4) (split-4 (drop l 4)))))

; (placeRandomCell game) places randomly value 2 or 4 in an empty cell of 'game'
; and returns as value the new game
(define (placeRandomCell game)
  (let* ([cell-list (apply append (Game-board game))]
         [empty-cells 
          (length (filter zero? cell-list))]
         [random-empty-cell (+ (random empty-cells prg) 1)]
         [random-value (* 2 (+ (random 2 prg) 1))])
    (Game 
     (split-4 (zero-replace random-empty-cell random-value cell-list))
     (Game-score game))))

; initializer of the game
(define (init-game) 
  (placeRandomCell 
   (placeRandomCell (Game 
                     '((0 0 0 0) 
                       (0 0 0 0) 
                       (0 0 0 0) 
                       (0 0 0 0)) 
                     0))))

; collapseRow
(require racket/stream)
(define (gen-values x)
  (stream-cons x (gen-values x))
)
(define (s-take n s)
  (cond [(= n 0) '()]
        [(procedure? s) (s-take n (s))]
        [else (cons (stream-first s) (s-take (- n 1) (stream-rest s)))]))
(define (collapseRow row)
  ;(append row (s-take (- 4 (length row)) (gen-values 0)))
  (append (collapseRowImpl row 0 (list)) (s-take (- 5 (length (collapseRowImpl row 0 (list)))) (gen-values 0)))
)
(define (collapseRowImpl row score acc)
  (cond
    [(empty? row) (append (list score) acc)]
    [(empty? (cdr row)) (collapseRowImpl (cdr row) score (append acc (list (car row))))]
    [(= (car row) (cadr row)) (collapseRowImpl (cddr row) (+ score (* 2 (car row))) (append acc (list (* 2 (car row)))))]
    [else (collapseRowImpl (cdr row) score (append acc (list (car row))))]
  )
)
   
; detect neighbor cells in a row
(define (neighbor-cells? row)
  (let ([neighbor-cells-aux 
         (lambda (a b c d) (or (= a b) (= b c) (= c d)))])
    (apply neighbor-cells-aux row)))

(define (horizontalCollisions? rows)
  (if (= (length rows) 1) 
      (neighbor-cells? (car rows))
      (or (neighbor-cells? (car rows)) (horizontalCollisions? (cdr rows)))))

; detect if the game is won
(define (isWon? game)
  (if (member 2048 (flatten (Game-board game))) #t #f)
)
  
(define (atom? x) (not (or (pair? x) (null? x))))
(define (one-big-list l acc)
  (cond
    [(empty? l) acc]
    [(atom? (car l)) (one-big-list (cdr l) (append acc (list (car l))))]
    [else (one-big-list (cdr l) (append acc (one-big-list (car l) '())))]
  )
)
(define (find n l)
  (cond
    [(empty? l) #f]
    [(= n (car l)) #t]
    [else (find n (cdr l))]
  )
)

; detect if the game is lost
(define (isLost? game)
  (cond  [(and (eq? (isWon? game) #f)
               (eq?(member 0 (flatten (Game-board game))) #f)
               (and (eq? (can-increase-score (Game-board game))#t) (eq? (can-increase-score (transpose (Game-board game)))#t)  #t))]
  		  [#t #f]))




; checks if increasing score is possible
(define (can-increase-score game)
  (cond
    [(empty? game) #f]
    [(not (= 0 (car (collapseRow(car game))))) #t]
    [else (can-increase-score (cdr game))]
  )
)

  
; transpose a matrix
(define (transpose A) 
  (if (eq? (length (car A)) 0) 
      null
      (cons (map car A) (transpose (map cdr A)))))

; MOVES

; (moveLeft game) simulates the shift of all tiles to the left
; the left shift of a row is performed as follows:
; 1) we remove all zero cells from a row; e.g., '(4 0 4 8) --> '(4 4 8)
;    this allows am east detection of colliding cells (e.g., 4,4 are colliding horizontal cells)
; 2) (collapseRow row-without-zero) performs all collisions, adds zero tiles to the end of the collapsed lists,
;    and adds the score of collisions on that row, as first element. 
;    We call such a row a 'row with score'
;    Examples: '() represents the empty row. No collisions occur => result '(0 0 0 0 0)
;              '(4 4 8) may represent any of the rows '(0 4 4 8) '(4 0 4 8) '(4 4 8 0) => result '(8 8 8 0 0)
; 3) the board of new game is list of 'rows with score', from which we drop the first element (the score)
; 4) the score of the new game is the old score, to which we add the scores from all 'rows with score'
;    In Racket, this computation is a simple call of (foldr + ...)

(define (moveLeft game)
  (define rows-with-score 
    (map (compose collapseRow (lambda (row) (filter non-zero? row))) 
                      (Game-board game)))
  (Game (map cdr rows-with-score) 
        (foldr + (Game-score game) (map car rows-with-score))))

; moveUp simulates the shift up of all tiles
; Note that a moveUp coincides with a transpose of the moveLeft of the transposed board
(define (moveUp game)
  (define rows-with-score 
    (map (compose collapseRow (lambda (row) (filter non-zero? row))) 
                      (transpose (Game-board game))))
  (Game (transpose (map cdr rows-with-score)) 
        (foldr + (Game-score game) (map car rows-with-score))))
  
;  (my-reverse game) creates the game configuration with all rows of the board reversed
(define (my-reverse game) (my-reverse-imp game '()))
(define (my-reverse-imp game acc)
  (cond
    [(empty? game) acc]
    [else (my-reverse-imp (cdr game) (append acc (list (reverse (car game)))))]
  )
)

; moveDown simulates the shift down of all tiles
; Note that a moveDown can be simulated as follows:
;    1) we perform a moveLeft of the transpose of the board obtained by reversing all rows.
;    2) The new board is obtained by reversing the rows of the previously computed board, 
;       and then transposing it

(define (moveDown game)
  (define rows-with-score
        (map (compose collapseRow (lambda (row) (filter non-zero? row))) 
             (my-reverse (transpose (Game-board game)))))
  (Game (transpose (my-reverse (map cdr rows-with-score) ))
        (foldr + (Game-score game) (map car rows-with-score))))






; moveRight simulates the shift to the right of all tiles
; Note that a moveRight can be simulated as follows:
;    1) we perform a moveLeft of the board obtained by reversing all rows.
;    2) The new board is obtained by reversing the rows of the previously computed board
(define (moveRight game)
  (define rows-with-score
        (map (compose collapseRow (lambda (row) (filter non-zero? row))) 
             (my-reverse (Game-board game))))
  (Game (my-reverse (map cdr rows-with-score) )
        (foldr + (Game-score game) (map car rows-with-score))))








; a functional that returns the function that performs the move 
; chosen by the user 
;   a             -> moveLeft
;   s             -> moveDown
;   w             -> moveUp
;   d             -> moveRight
;   anything-else -> no move (that is, identity function)
(define (getMove)
  (display "Next move [w/a/s/d]: ")
  (let ([k (read)])
    (if (eq? k 'w) moveUp
        (if (eq? k 'a) moveLeft
            (if (eq? k 's) moveDown
                (if (eq? k 'd) moveRight
                    (lambda (x) (displayln "Unknown move") x)))))))

(define (play game)
  (show game)
  (if (isWon? game)
      (displayln "Winner!")
      (if (isLost? game)
          (displayln "Game over!")
          (let ([newgame ((getMove) game)])
            (play (if (equal? game newgame)
                      newgame
                      (placeRandomCell newgame)))))))
  
(define (interactive) (play (init-game)))

(define (choose-next-game game)
  (define game-choices 
    (filter (lambda (g) (not (equal? g game)))
            (map (lambda (move) (move game)) (list moveLeft moveRight moveUp moveDown))))
  ; choose from next-game-choices the game with most zeroes on the board
  (define zeroList 
    (map (lambda (g) 
           (length (filter zero? (apply append (Game-board g))))) 
         game-choices))
  (getGameWithMostZeros game-choices zeroList))

(define (getGameWithMostZeros games zeros)
  (if (= (length games) 1)
      (car games)
      (if (< (list-ref zeros 0) (list-ref zeros 1))
          ; eliminate first game and it's corresponding number of zeros
          (getGameWithMostZeros (cdr games) (cdr zeros))
          ; eliminate second game and it's corresponding number of zeros
          (getGameWithMostZeros 
           (cons (car games) (cddr games))
           (cons (car zeros) (cddr zeros))))))
  
(define (solitary) (play-solitary (init-game)))

(define (play-solitary game)
  (show game)
  (if (isWon? game)
      (displayln "Winner!")
      (if (isLost? game)
          (displayln "Game over!")
          (begin
            (displayln "Press any key...")
            (read-char)
            (play-solitary (placeRandomCell (choose-next-game game)))))))

  